\documentclass{article}
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}

\addtolength{\topmargin}{-1in}
\addtolength{\textheight}{1.75in}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\title{\textbf{CS152/154}}
\author{Shubh Kumar}
\date{IIT-B,Spring Semester 2021}

\begin{document}

\maketitle

\section{Lecture 1: Review of Program Design}
\begin{itemize}
    \item \textbf{Conceptualization:} The theorems, proofs, Design, suitability, satisfiability
    \item When Software began becoming complex, only then people understood the importance of Program Design.
    \item \textbf{Re-usability:} Making Programs like Black-Box like Components which can be simply put somewhere else, this is done by making the program standardized and having it adhere to specifications. We need to structure our programs so that many of these form a particular structure which can be reused somewhere else, or can be put from somewhere else.
    \item \textbf{Data and Control Abstractions:} Flow of data and the abstractions which allow us to change the data/state comes under Control Abstractions. The way we store this data could be comes under Data Abstractions.
    \item Control in real life and thus in programs have many branches through which you want to change the state.
    \item Boolean, Integers, stuff like this come under Data Abstractions,
    there are these basic data abstractions, using which we could structure more complex data abstractions.
    \item \textbf{Programming with Assertions:}Asserting gives us defences against some mistakes we may have unknowingly made in the program. We add assert statements which terminate the program just as soon as the assert conditions goes false
    \item \textbf{Reasoning about Programs: Proving correctness} How to make sure that what we are doing is correct
    \item \textbf{Imperative Programming Ideas:} Ideas revolving around the change of states as the basis of Programming
    \item \textbf{Applicative Programming Ideas:} Ideas around functions operating on arguments as the basis of programming
    \item \textbf{Procedural Paradigm:} The way its done in C,C++, FORTRAN i.e. We have some procedures and global variables.
    \item \textbf{Object-Oriented Programming Ideas:} Ideas revolving around packaging into objects

\end{itemize}

\section{Lecture 2 : Monday's Lab Discussion}

\begin{itemize}
    \item The C program was supposed to be procedural, whereas the C++ program needs to be Object-oriented

    \item A Good Programming Practice is to declare all the variables in the beginning of the main function/file.

    \item Commenting usage/documentation in the beginning is another
    great programming habit.

    \item \textbf{C++ Resource:} \href{www.cplusplus.com}{Click Here}
    \item \textbf{Linux Commands:}
    \begin{itemize}
        \item man command in Linux: To Find documentation
         \item mv command in Linux: To Move files from one place to a folder
         \item For more basic commands \href{https://www.hostinger.in/tutorials/linux-commands}{Go here.}
    \end{itemize}

     \item srand() sets the seed, which is basically an attribute for a beautiful random number generator, if we have the same seed or set no seed, then it'll give the same seed no matter how many times we run. Thus, We should almost always use srand() and a seed whenever we use rand()
\end{itemize}

\section{Lecture 3: Critical Discussion on Monday's Lab and Programming Discipline}

\begin{itemize}
    \item \verb|#include<...>| includes header files, which are links to other pre-defined libraries.
    \item \verb|using namespace ...| includes a particular set of functions(in namespace, ie the space of all possible names) which identify with a particular library/task named in \ldots
    \item \textbf{Proper Spacing: } \verb|int main () {}| is better than \verb|int main(){}| , but not too many spaces and also like \verb|cout << "hello\n";| instead of \verb|cout<<"hello\n";|
    \item \verb|printf(10)| and similar would give error, as the first argument is supposed to be only the format, and only in the placeholders could numbers be added.
    \item If we try to print something without initialization, it prints garbage values.
    \item For \verb|printf()| and \verb|scanf()| syntax properly \href{http://www.cplusplus.com/reference/cstdio/}{Click Here}.

\end{itemize}

\section{Lecture 4: Abstract Data Types}
\begin{itemize}
  \item  We'll be requiring \verb|libfltk1.3| and \verb|fluid|(part of Fast Light Toolkit), for graphics as the course progresses.
  \item When there's an interaction between different variables, Global Variables become useful, although they do have their drawbacks.
  \item The expressions in Programs are of two kinds, Data and Control.
  \item Data represents the state Problem Domain, and Control represents Data Manipulation to get various results.
  \item Compilers give us the feature to construct newer Data Abstractions, and overloading the operators on the pre-existing data types and stuff.
  \item Even the primitive Data Types have arosen from some abstractions, abstracting meaning from the way bits are set in memory.
  \item Compilers also give us type-safety: We can't operate on two variables whose types are such that the operator doesn't carry any meaning.
  \item Data Abstractions are of three types: Input, Output and Intermediate
  \item eg. The output maybe an array, when the input was a matrix and in the process of moving from one to the other it may have went through Stacks, Queues etc.
  \item Abstracting different notions as data types helps in Re-usability.
\end{itemize}

\section{Lecture 5: Abstract Data Types (Continued!)}
\begin{itemize}
  \item Once, you're familiar with the applications in a domain, its always easier to find abstractions with which you could program those applications.
  \item If you go from domain to domain, the terminologies they use change, and thus so does the abstractions. Eg. Hospitals and Schools have different abstractions that they care about!
  \item Language gives you, the very basic abstractions in form of various data types: int(s), float(s), function calls etc.
  \item Learning Data Structures brings a lot of more ideas about implementing these data abstractions in programs.
  \item Class represents the abstraction of data. Object is an instance of that class.
  \item \textbf{Functional Representation:} Manipulating these data-abstractions similar to the way we define mathematical equations.
  \begin{itemize}
    \item Analyzing various aspects of the Data Abstractions, to get an idea of its properties, and then deducing mathematical relations from them, which could simplify our work!
    \item The Example of a stack:
    \begin{itemize}
    \item For a stack, we could easily write that if the stack is \verb|X|, then if the last manipulation of the stack using \verb|push| or \verb|pop| is \verb|push(X,a)|, then \verb|top(X)| will give \verb|a|.
    \item Similarly, we also observe that in case, if the last manipulation was \verb|pop|, then what we do is simply go over the latest manipulations and the very time, where we see that the number of usages of the \verb|push| is more than \verb|pop|, than the element which is causing this difference of one would give us the result of \verb|top|.
    \item If we were to do this abstraction without using the stack data-structure, then computing the result of \verb|top|, could be calculated in $O(\log n)$ time, where $n$ is the number of such commands we've come across so far.
    \item But, that won't be required if we use the stack data-structure(abstraction)!, and then we would be able to perform \verb|push, pop| or \verb|top| in constant time, demonstrating the usefulness of data abstractions.
    \item Other Observations would be \verb|empty(new())| will always return true, \verb|removetop(push(X,t))| will give back \verb|X|(i.e. The Stack before \verb|t| was added will be the same as the one we'll get if we remove the top element of the stack after adding the top-element),
    \verb|not empty(push(X,t))| will be always true as if we push something into the stack than it couldn't possibly be empty.
    \end{itemize}
    \item In the last expression, we observe how mathematics could help us better represent the functional aspect of various Data Abstractions.
  \end{itemize}
\end{itemize}

\section{Lecture 6: Abstract Data Types(Still Continued!)}
\begin{itemize}
  \item We want to package our program into different classes and objects, so that they are abstracted and only interact with the outside world through some interfaces, in the same way that electronics and other stuff interact with the world using buttons, Ports.
  \item These abstractions essentially define a protocol of interacting with these objects.
  \item Just like any eletronic product has all of its Components, are made in different places and then assembled, so that each of these componenets have their own abstractions, the same stands true for Programming Abstractions.
  \item When you're the manufacturer, you'd understand everything that happens inside the blackbox of the abstraction, because you'd want to keep it improving, But if you just want it to develop an application of it, you don't care about that. The same paradigms apply to Abstractions in Programming.
  \item Abstractions usually have a hierarchy, one abstraction used by another which is yet used by another.
  \item Concepts in Physics, Chemistry, Biology could be all taken to be abstractions, with some commmon abstractions spanning across all subjects.
  \item The Nouns/Terminology changing gives us the set of abstractions.
  \item We come up with abstractions so that at the next level, we can forget how these things work, and not care about them!
  \item Abstractions could thus be taken as a higher level view of stuff.
  \item \textbf{Designing Tips:}
  \begin{itemize}
    \item Keep Program Compilable throughout.
    \item Don't wait till the end to Compile.
    \item Define the Functions outside the main class, In the class Declaration keep only the declarations of this function, implement these later.
    \item We need to have Destructor/Constructor implementations, if we've declared it before hand, as when we create that object the Constructor would definitely be called and when the program ends, the Destructor would definitely be called.
  \end{itemize}

\end{itemize}

\section{Lecture 7: Abstract Data Types(still continued!)}
\begin{itemize}
  \item  Declarations give us Abstractions, and definitions give us implementations.
  \item  Interface is what is available on the object to operate it.
  \item This is interface comes from the public functions/variables of the Object's Class.
  \item Any file with any declarations could be compiled as an object file, by using \verb|g++ -c|.
  \item The Object file could be used later.
  \item \textbf{Encapsulation:} Package all variables/functions together as a single unit, either as a \verb|struct| or \verb|class|. Also, these shouldn't be able to easily accessible from outside this unit!
  \item Some variables are simply not meant to be global, like phone numbers in a mobile etc., so we shouldn't keep them global, but specific to various classes. Even better keep them private to whatever extent you can.
  \item If we don't Encapsulate, We need to deal with all componenets separately and hence, we'll have to pass these instances to global functions in order to manipulate them!
  \item Structures could help us solve the above problems to some extent, but its Classes which finally allows us to increase security further as well as preventing repetitive passing of these Encapsulated Structures to functions(which requires time as it includes copying the entire variable!).
  \item Big Classes and Big Functions are to be prevented. All these functions, variables for each class should be at the top, so that it could be comprehended easily, and the interactions should be described there itself in comments so that whoever is reading could understand it there itself.
  \item That's why the declarations should be separated from the definitions!
\end{itemize}

\section{Lecture 8: Abstractions as State Machines}

\begin{itemize}
  \item When we view Abstractions as State Machines, then manipulations made in the main funciton are like Human guards which have access inside the machine. We should keep at least those things in the main() function.
  \item  Every incoming member function call to an object/Abstractions which serves as State Machine must satisfy its pre-conditions . Eg.Can't pop from empty stack, can't push to full one!
  \item These pre-conditions should be checked inside the abstractions(object!).
  \item Transitions between the states of these state machine of ours could be viewed as Call to various member functions which are interacting with each other.
  \item Practice: Drawing SMs for various Abstractions.
  \item In Complex SMs, We don't show actions which aren't allowed. Simply write if it isn't allowed then give error
  \item In the Telephone Program, We should have each of the individual states as a different member function so that, when that function is running, then it could be the indication of being in that state.
  \item Thus, We should've had separate member functions for Dialing, Connecting, Conversing etc.
\end{itemize}

I didn't make notes for most of the portions in the second half of the First half-sem as I thought it wasn't helping much! \\
I did realize this course was a vague one and without summarizing the lectures, it becomes pretty clueless for one to figure what to study before exams. Hence:

\section {Lecture on May 3: Assertions}

\begin{itemize}
  \item When we write the proof on paper, it has various steps, we would want to make sure these steps were indeed correct and we make sure of this by using assertions, which inform us if we were correct w.r.t the proof.
  \item Debugger is a post-development way to do so, Assertion is a way to do so during Runtime itself. We have certain breakpoints/checkpoints in the code, where we print something to check, if what we intend to do was correct.
  \item Exceptions are also a way to handle errors in runtime itself.
  \item \verb|assert|, helps us check if a particular condition is satisfied at a particular step.
  \item \verb|assert| is like a demonstration of correctness.
  \item \verb|assert| is more about finding bugs and you may not add it in the end of the program!
  \item \verb|try| and \verb|catch| enable us to have error handling in run-time, we generally remove assertions after we've fixed all the bugs!
  \item \verb|#define NDEBUG| , the assertions are turned off, thereby providing us with a way to not have assertions messing the way our program runs.
\end{itemize}

\section{Lecture on May 5: Aseertions for Program Correctness}

\begin{itemize}
  \item We use Assertions for Program Correctness and then remove it after we're done, its like After building a building we are removing the structures which were put up initially to make sure the building's structure was intact.
  \item The Program Correctness part is only upto O(n) for any method.
  \item Functions which check the correctness will be used inside the assert function itself.
  \item Also, a custom-made macro is called in the same scope from which its called, any method/variable in the scope of the place from where the macro is called, can be used inside the functions part of the assertion's condition or the Macro itself.
\end{itemize}

\end{document}
